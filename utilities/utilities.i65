; 16 bit utility macros for the 65C02 processor.
; File: utilities.i65

; Initialize a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; value - a value used to initialize var.
; Notes: Unless value is 0, clobbers the A register, Z and N flags.
;        Optimized for special cases like 0, 1..255, $100..$FF00
.macro set_var_16 var,value
.ifconst value                         ; Is value resolved at assembly time?
  .if .lowbyte(value)                  ; Do we need to copy the low byte?
    lda #.lowbyte(value)
    sta var
  .else                                ; Or can we just zap it?
    stz var
  .endif

  .if .highbyte(value)                 ; Do we need to copy the high byte?
    lda #.highbyte(value)
    sta var+1
  .else                                ; Or can we just zap it too?
    stz var+1
  .endif

.else                                  ; We need to copy both bytes.
  lda #.lowbyte(value)
  sta var
  lda #.highbyte(value)
  sta var+1
.endif
.endmacro

; Initialize a 16 bit variable in memory pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; value - a value used to initialize the target data.
; Notes: Clobbers the Y register, Z and N flags and unless value is 0 also A.
;        Optimized for special cases like 0, 1..255, $100..$FF00
.macro set_zpp_16 zpp,value
.ifconst value                         ; Is value resolved at assembly time?

  .if .lowbyte(value)                  ; Do we need to copy the low byte?
    lda #.lowbyte(value)
    sta (zpp)
  .else                                ; Or can we just zap it?
    stz (zpp)
  .endif



.else                                  ; We need to copy both bytes.

.endif

.endmacro


; Initialize a 16 bit variable in memory pointed to by a zp pointer
; indexed by the Y register.

; INCREMENT - Add 1

; Increment a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; Notes: Clobbers the Z and N flags.
.macro inc_var_16 var
  .local no_wrap
  inc var
  bne no_wrap
  inc var+1
no_wrap:
.endmacro

; Increment a 16 bit variable pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; Notes: Clobbers the Y register, Z and N flags.
.macro inc_zpi_16 zpp
  .local no_wrap
  inc (zpp)
  bne no_wrap
  ldy #1
  inc (zpp),y
no_wrap:
.endmacro

; Increment a 16 bit variable pointed to by a zero page pointer
; indexed by the Y register.

; Decrement a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; Notes: Clobbers the A register, Z and N flags.
.macro dec_var_16 var
  .local no_wrap
  lda var
  bne no_wrap
  dec var+1
no_wrap:
  dec var
.endmacro

; Decrement a 16 bit variable pointed to by a zero page pointer
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; Notes: Clobbers the A and Y registers, Z and N flags.
.macro dec_zpi_16 zpp
  .local no_wrap
  lda (zpp)
  bne no_wrap
  ldy #1
  dec (zpp),y
no_wrap:
  dec (zpp)
.endmacro

; Decrement a 16 bit variable pointed to by a zero page pointer
; indexed by the Y register.

; Adjust a 16 bit variable in memory by a literal amount.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   step - an integer constant to be added to var.
; Notes: Clobbers the A register, C, V, Z and N flags.
;        Optimized for special cases like a step of 0, 1..255, $100..$FF00
.macro adj_var_16 var,step
  .local no_carry
  .ifconst(step)                       ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lowbyte(step)                 ; Do we need to process the low byte?
      lda var
      adc #.lowbyte(step)
      sta var
    .endif

    .if .highbyte(step)                ; Do we need to process the high byte?
      lda var+1
      adc #.highbyte(step)
      sta var+1
    .elseif .lowbyte(step)             ; or pass low byte carry if it exists.
      bcc no_carry
      inc var+1
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda var
    adc #.lowbyte(step)
    sta var
    lda var+1
    adc #.highbyte(step)
    sta var+1
  .endif
no_carry:
.endmacro

; Adjust a 16 bit variable pointed to by a zero page pointer by a literal amount.

; Adjust a 16 bit variable pointed to by a zero page pointer indexed by the Y
; register by a literal amount.

; Test a 16 bit variable in memory.

; Test a 16 bit variable in memory pointed to by a zero page pointer.

; Test a 16 bit variable in memory pointed to by a zp pointer
; indexed by the Y register.
