; Some 16 bit utility macros for the 65C02 processor.

; set_var_16
; Initialize a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; value - a value used to initialize var.
; Notes:
;   Unless value is 0, clobbers the A register, Z and N flags.
;   Optimized for special cases like 0, 1..255, $100..$FF00
.macro set_var_16 var,value
.ifconst value                         ; Is value resolved at assembly time?
  .if .lowbyte(value)                  ; Do we need to copy the low byte?
    lda #.lowbyte(value)
    sta var
  .else                                ; Or can we just zap it?
    stz var
  .endif

  .if .highbyte(value)                 ; Do we need to copy the high byte?
    lda #.highbyte(value)
    sta var+1
  .else                                ; Or can we just zap it too?
    stz var+1
  .endif

.else                                  ; We need to copy both bytes.
  lda #.lowbyte(value)
  sta var
  lda #.highbyte(value)
  sta var+1
.endif
.endmacro

; set_zpp_16
; Initialize a 16 bit variable in memory pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; value - a value used to initialize the target data.
; Notes:
;   Clobbers the A and Y registers, Z and N flags.
.macro set_zpp_16 zpp,value
  lda #.lowbyte(value)
  sta (zpp)
  ldy #1
  lda #.highbyte(value)
  sta (zpp),y
.endmacro

; set_zpy_16
; Initialize a 16 bit variable in memory pointed to by a zp pointer indexed by
; the Y register.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
; value - a value used to initialize the target data.
; Notes:
;   Clobbers the A register, Z and N flags.
;   Page wrap failure if Y == $FF on entry.
.macro set_zpy_16 zpy,value
  lda #.lowbyte(value)
  sta (zpy),y
  iny
  lda #.highbyte(value)
  sta (zpy),y
  dey
.endmacro

; inc_var_16
; Increment a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; Notes:
;   Clobbers the Z and N flags.
.macro inc_var_16 var
  .local no_wrap
  inc var
  bne no_wrap
  inc var+1
no_wrap:
.endmacro

; inc_zpp_16
; Increment a 16 bit variable pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; Notes:
;   Clobbers the Y register, Z and N flags.
.macro inc_zpp_16 zpp
  .local no_wrap
  inc (zpp)
  bne no_wrap
  ldy #1
  inc (zpp),y
no_wrap:
.endmacro

; inc_zpy_16
; Increment a 16 bit variable pointed to by a zero page pointer indexed by the
; Y register.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
; Notes:
;   Clobbers the Z and N flags.
;   Page wrap failure if Y == $FF on entry.
.macro inc_zpy_16 zpy
  .local no_wrap
  inc (zpp),y
  bne no_wrap
  iny
  inc (zpp),y
  dey
no_wrap:
.endmacro

; dec_var_16
; Decrement a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; Notes:
;   Clobbers the A register, Z and N flags.
.macro dec_var_16 var
  .local no_wrap
  lda var
  bne no_wrap
  dec var+1
no_wrap:
  dec var
.endmacro

; dec_zpp_16
; Decrement a 16 bit variable pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; Notes:
;   Clobbers the A and Y registers, Z and N flags.
.macro dec_zpp_16 zpp
  .local no_wrap
  lda (zpp)
  bne no_wrap
  ldy #1
  dec (zpp),y
no_wrap:
  dec (zpp)
.endmacro

; dec_zpy_16
; Decrement a 16 bit variable pointed to by a zero page pointer indexed by the
; Y register.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
; Notes:
;   Clobbers the A register, Z and N flags.
;   Page wrap failure if Y == $FF on entry.
.macro dec_zpy_16 zpy
  .local no_wrap
  lda (zpy),y
  bne no_wrap
  iny
  dec (zpy),y
  dey
no_wrap:
  dec (zpy),y
.endmacro

; adj_var_16
; Adjust a 16 bit variable in memory by a literal amount.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   step - an integer constant to be added to var.
; Notes:
;   Clobbers the A register, C, V, Z and N flags.
;   Optimized for special cases like a step of 0, 1..255, $100..$FF00
.macro adj_var_16 var,step
  .local no_carry
  .ifconst(step)                       ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lowbyte(step)                 ; Do we need to process the low byte?
      lda var
      adc #.lowbyte(step)
      sta var
    .endif

    .if .highbyte(step)                ; Do we need to process the high byte?
      lda var+1
      adc #.highbyte(step)
      sta var+1
    .elseif .lowbyte(step)             ; or pass low byte carry if it exists.
      bcc no_carry
      inc var+1
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda var
    adc #.lowbyte(step)
    sta var
    lda var+1
    adc #.highbyte(step)
    sta var+1
  .endif
no_carry:
.endmacro

; adj_zpp_16
; Adjust a 16 bit variable pointed to by a zero page pointer by a
; literal amount.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   step - an integer constant to be added to var.
; Notes:
;   Clobbers the A and Y registers, C, V, Z and N flags.
;   Optimized for special cases like a step of 0, 1..255, $100..$FF00
.macro adj_zpp_16 zpp,step
  .local no_carry
  .ifconst(step)                       ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lowbyte(step)                 ; Do we need to process the low byte?
      lda (zpp)
      adc #.lowbyte(step)
      sta (zpp)
    .endif

    .if .highbyte(step)                ; Do we need to process the high byte?
      ldy #1
      lda (zpp),y
      adc #.highbyte(step)
      sta (zpp),y
    .elseif .lowbyte(step)             ; or pass low byte carry if it exists.
      ldy #1
      bcc no_carry
      inc (zpp),y
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda (zpp)
    adc #.lowbyte(step)
    sta (zpp)
    ldy #1
    lda (zpp),y
    adc #.highbyte(step)
    sta (zpp),y
  .endif
no_carry:
.endmacro

; adj_zpy_16
; Adjust a 16 bit variable pointed to by a zero page pointer indexed by the Y
; register by a literal amount.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
;   step - an integer constant to be added to var.
; Notes:
;   Clobbers the A register, Z and N flags.
;   Page wrap failure if Y == $FF on entry.
.macro adj_zpy_16 zpy,step
  .local no_carry
  .ifconst(step)                       ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lowbyte(step)                 ; Do we need to process the low byte?
      lda (zpy),y
      adc #.lowbyte(step)
      sta (zpy),y
    .endif

    .if .highbyte(step)                ; Do we need to process the high byte?
      iny
      lda (zpp),y
      adc #.highbyte(step)
      sta (zpp),y
      dey
    .elseif .lowbyte(step)             ; or pass low byte carry if it exists.
      iny
      bcc no_carry
      inc (zpp),y
      dey
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda (zpy),y
    adc #.lowbyte(step)
    sta (zpy),y
    iny
    lda (zpy),y
    adc #.highbyte(step)
    sta (zpy),y
    dey
  .endif
no_carry:
.endmacro

; tst_var_16
; Test a 16 bit variable in memory.
; Parameters:
; Notes:
;wip

; tst_zpp_16
; Test a 16 bit variable in memory pointed to by a zero page pointer.
; Parameters:
; Notes:
;wip

; tst_zpy_16
; Test a 16 bit variable in memory pointed to by a zp pointer indexed by the Y
; register.
; Parameters:
; Notes:
;wip
