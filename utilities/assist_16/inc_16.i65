; Macros to increment 16-bit values.

.ifndef assist_inc_16_included
assist_inc_16_included = 1

.macro _inc_var_16 var
  .local no_wrap
  inc var
  bne no_wrap
  inc var+1
no_wrap:
.endmacro

.macro _inc_vax_16 var
  .local no_wrap
  inc var,x
  bne no_wrap
  inc var+1,x
no_wrap:
.endmacro

.macro _inc_vay_16 var
  .local no_wrap
  lda var,y
  inc
  sta var,y
  bne no_wrap
  lda var+1,y
  inc
  sta var+1,y
no_wrap:
.endmacro

.macro _inc_zpp_16 var
  .local no_wrap
  lda (var)
  inc
  sta (var)
  bne no_wrap
  ldy #1
  lda (var),y
  inc
  sta (var),y
no_wrap:
.endmacro

.macro _inc_zpy_16 var
  .local no_wrap
  lda (var),y
  inc
  sta (var),y
  bne no_wrap
  iny
  lda (var),y
  inc
  sta (var),y
  dey
no_wrap:
.endmacro

; inc_16
; Increment a 16 bit variable in memory.
; Parameters:
;   var - a 16 bit variable.
; Notes:
;   zp, abs : Clobbers the Z and N flags.
;   zpi     : Clobbers the A and Y register, Z and N flags.
;   zpy     : Clobbers the A register and the Z and N flags.
.macro inc_16 dst
  .if (.match({dst}, {(name)}))
    _inc_zpp_16 .mid(1, 1, {dst})
  .elseif (.match({dst}, {(name),y}))
    _inc_zpy_16 .mid(1, 1, {dst})
  .elseif (.match({dst}, {name,x}))
    _inc_vax_16 .mid(0, 1, {dst})
  .elseif (.match({dst}, {name,y}))
    _inc_vay_16 .mid(0, 1, {dst})
  .else
    _inc_var_16 {dst}
  .endif
.endmacro

.endif
