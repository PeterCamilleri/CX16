; Macros to adjust (addto/subtract from) 16-bit values.

.ifndef assist_adj_16_included
assist_adj_16_included = 1

.macro _adj_var_16 var,step
  .local no_carry
  .ifconst step                        ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lobyte(step)                  ; Do we need to process the low byte?
      lda var
      adc #.lobyte(step)
      sta var
    .endif

    .if .hibyte(step)                  ; Do we need to process the high byte?
      lda var+1
      adc #.hibyte(step)
      sta var+1
    .elseif .lobyte(step)              ; or pass low byte carry if it exists.
      bcc no_carry
      inc var+1
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda var
    adc #.lobyte(step)
    sta var
    lda var+1
    adc #.hibyte(step)
    sta var+1
  .endif
no_carry:
.endmacro

.macro _adj_zpp_16 zpp,step
  .local no_carry
  .ifconst step                        ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lobyte(step)                  ; Do we need to process the low byte?
      lda (zpp)
      adc #.lobyte(step)
      sta (zpp)
    .endif

    .if .hibyte(step)                  ; Do we need to process the high byte?
      ldy #1
      lda (zpp),y
      adc #.hibyte(step)
      sta (zpp),y
    .elseif .lobyte(step)              ; or pass low byte carry if it exists.
      bcc no_carry
      ldy #1
      lda (zpp),y
      inc
      sta (zpp),y
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda (zpp)
    adc #.lobyte(step)
    sta (zpp)
    ldy #1
    lda (zpp),y
    adc #.hibyte(step)
    sta (zpp),y
  .endif
no_carry:
.endmacro

.macro _adj_zpy_16 zpy,step
  .local no_carry
  .ifconst step                        ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lobyte(step)                  ; Do we need to process the low byte?
      lda (zpy),y
      adc #.lobyte(step)
      sta (zpy),y
    .endif

    .if .hibyte(step)                  ; Do we need to process the high byte?
      iny
      lda (zpy),y
      adc #.hibyte(step)
      sta (zpy),y
      dey
    .elseif .lobyte(step)              ; or pass low byte carry if it exists.
      bcc no_carry
      iny
      lda (zpy),y
      inc
      sta (zpy),y
      dey
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda (zpy),y
    adc #.lobyte(step)
    sta (zpy),y
    iny
    lda (zpy),y
    adc #.hibyte(step)
    sta (zpy),y
    dey
  .endif
no_carry:
.endmacro

; adj_16
; Adjust a 16 bit variable in memory by a literal amount.
; Parameters:
;   var - a 16 bit variable.
;   step - an integer constant to be added to var.
; Notes:
;   zp, abs : Clobbers the A register, C, V, Z and N flags.
;   zpi     : Clobbers the A and Y registers, C, V, Z and N flags.
;   zpy     : Clobbers the A register, C, V, Z and N flags.
;
; Optimized for special cases like a step of 0, 1..255, $100..$FF00
.macro adj_16 dst,value
  .if (.match({dst}, {(name)}))
    _adj_zpp_16 .mid(1, 1, {dst}),value
  .elseif (.match({dst}, {(name),y}))
    _adj_zpy_16 .mid(1, 1, {dst}),value
  .else
    _adj_var_16 {dst},value
  .endif
.endmacro

.endif
