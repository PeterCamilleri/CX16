; Macros to compare a 16-bit variable to a value.

.ifndef assist_cmp_16_included
assist_cmp_16_included = 1

.macro _cmp_var_16 var, value
  .local not_equal
  .local all_done

  sec
  lda var                              ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  lda var+1                            ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  lda var+1                            ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

.macro _cmp_zpp_16 zpp, value
  .local not_equal
  .local all_done

  sec
  ldy #1
  lda (zpp)                            ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  lda (zpp),y                          ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  lda (zpp),y                          ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

.macro _cmp_zpy_16 zpy, value
  .local not_equal
  .local all_done

  sec
  lda (zpy),y                          ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  iny
  lda (zpy),y                          ; Get the high byte of data.
  dey
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  iny
  lda (zpy),y                          ; Get the high byte of data.
  dey
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

; cmp_16
; Compare a 16 bit variable in memory with a value.
; Parameters:
;   var - a 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The N, V, Z, and C flags are set.
;   C is set if var >= value using unsigned comparison.
;   (N xor V) is cleared if var >= value using signed comparison.
;   Z is set if var = value
; Notes:
;   zp, abs : Clobbers the A register.
;   zpi     : Clobbers the A and Y registers.
;   zpy     : Clobbers the A register.
;
;   Optimized for special cases like values of $xx00.
.macro cmp_16 dst,value
  .if (.match({dst}, {(name)}))
    _cmp_zpp_16 .mid(1, 1, {dst}),value
  .elseif (.match({dst}, {(name),y}))
    _cmp_zpy_16 .mid(1, 1, {dst}),value
  .else
    _cmp_var_16 {dst},value
  .endif
.endmacro

.endif
