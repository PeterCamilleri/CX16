; Some 16 bit utility macros for the 65C02 processor.

; This is the top level include file that brings in all of the other include
; files. If finer grain control is desired, you can include files at a lower
; level. This is useful if only a few macros are required.

; The code contains safeguards against multiple file inclusion.

.include "set_16.i65"
.include "inc_16.i65"

; dec_var_16
; Decrement a 16 bit variable in memory.
; Parameters:
;   var - the name of a zero page or absolute addressed 16 bit variable.
; Notes:
;   Clobbers the A register, Z and N flags.
.macro dec_var_16 var
  .local no_wrap
  lda var
  bne no_wrap
  dec var+1
no_wrap:
  dec var
.endmacro

; dec_zpp_16
; Decrement a 16 bit variable pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; Notes:
;   Clobbers the A and Y registers, Z and N flags.
.macro dec_zpp_16 zpp
  .local no_wrap
  lda (zpp)
  bne no_wrap
  ldy #1
  dec (zpp),y
no_wrap:
  dec (zpp)
.endmacro

; dec_zpy_16
; Decrement a 16 bit variable pointed to by a zero page pointer indexed by the
; Y register.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
; Notes:
;   Clobbers the A register, Z and N flags.
;   Page wrap failure if Y == $FF on entry.
.macro dec_zpy_16 zpy
  .local no_wrap
  lda (zpy),y
  bne no_wrap
  iny
  dec (zpy),y
  dey
no_wrap:
  dec (zpy),y
.endmacro

; adj_var_16
; Adjust a 16 bit variable in memory by a literal amount.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   step - an integer constant to be added to var.
; Notes:
;   Clobbers the A register, C, V, Z and N flags.
;   Optimized for special cases like a step of 0, 1..255, $100..$FF00
.macro adj_var_16 var,step
  .local no_carry
  .ifconst step                        ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lobyte(step)                  ; Do we need to process the low byte?
      lda var
      adc #.lobyte(step)
      sta var
    .endif

    .if .hibyte(step)                  ; Do we need to process the high byte?
      lda var+1
      adc #.hibyte(step)
      sta var+1
    .elseif .lobyte(step)              ; or pass low byte carry if it exists.
      bcc no_carry
      inc var+1
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda var
    adc #.lobyte(step)
    sta var
    lda var+1
    adc #.hibyte(step)
    sta var+1
  .endif
no_carry:
.endmacro

; adj_zpp_16
; Adjust a 16 bit variable pointed to by a zero page pointer by a
; literal amount.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   step - an integer constant to be added to var.
; Notes:
;   Clobbers the A and Y registers, C, V, Z and N flags.
;   Optimized for special cases like a step of 0, 1..255, $100..$FF00
.macro adj_zpp_16 zpp,step
  .local no_carry
  .ifconst step                        ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lobyte(step)                  ; Do we need to process the low byte?
      lda (zpp)
      adc #.lobyte(step)
      sta (zpp)
    .endif

    .if .hibyte(step)                  ; Do we need to process the high byte?
      ldy #1
      lda (zpp),y
      adc #.hibyte(step)
      sta (zpp),y
    .elseif .lobyte(step)              ; or pass low byte carry if it exists.
      bcc no_carry
      ldy #1
      inc (zpp),y
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda (zpp)
    adc #.lobyte(step)
    sta (zpp)
    ldy #1
    lda (zpp),y
    adc #.hibyte(step)
    sta (zpp),y
  .endif
no_carry:
.endmacro

; adj_zpy_16
; Adjust a 16 bit variable pointed to by a zero page pointer indexed by the Y
; register by a literal amount.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
;   step - an integer constant to be added to var.
; Notes:
;   Clobbers the A register, Z and N flags.
;   Optimized for special cases like a step of 0, 1..255, $100..$FF00
;   Page wrap failure if Y == $FF on entry.
.macro adj_zpy_16 zpy,step
  .local no_carry
  .ifconst step                        ; Is step resolved at assembly time?
    .if step                           ; This is not a case of adding 0? Right?
      clc
    .endif

    .if .lobyte(step)                  ; Do we need to process the low byte?
      lda (zpy),y
      adc #.lobyte(step)
      sta (zpy),y
    .endif

    .if .hibyte(step)                  ; Do we need to process the high byte?
      iny
      lda (zpp),y
      adc #.hibyte(step)
      sta (zpy),y
      dey
    .elseif .lobyte(step)              ; or pass low byte carry if it exists.
      bcc no_carry
      iny
      inc (zpy),y
      dey
    .endif

  .else                                ; No, we need to add both bytes.
    clc
    lda (zpy),y
    adc #.lobyte(step)
    sta (zpy),y
    iny
    lda (zpy),y
    adc #.hibyte(step)
    sta (zpy),y
    dey
  .endif
no_carry:
.endmacro

; tst_var_16
; Test a 16 bit variable in memory.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
; Returns:
;   The N and Z flags are set according to the value tested.
; Notes:
;   Clobbers the A register.
.macro tst_var_16 var
  .local all_done
  lda var+1                            ; Get the high byte and test it.
  bmi all_done
  ora var                              ; Merge in the low byte.
  bpl all_done                         ; Deal with false negatives.
  lda #1
all_done:
.endmacro

; tst_zpp_16
; Test a 16 bit variable in memory pointed to by a zero page pointer.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
; Returns:
;   The N and Z flags are set according to the value tested.
; Notes:
;   Clobbers the A and Y registers.
.macro tst_zpp_16 zpp
  .local all_done
  ldy #1
  lda (zpp),y                          ; Get the high byte and test it.
  bmi all_done
  ora (zpp)                            ; Merge in the low byte.
  bpl all_done                         ; Deal with false negatives.
  lda #1
all_done:
.endmacro

; tst_zpy_16
; Test a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
; Returns:
;   The N and Z flags are set according to the value tested.
; Notes:
;   Clobbers the A register.
;   Page wrap failure if Y == $FF on entry.
.macro tst_zpy_16 zpy
  .local all_done
  iny                                  ; Get the high byte
  lda (zpy),y
  dey
  ora #0                               ; Test it.
  bmi all_done
  ora (zpy),y                          ; Merge in the low byte.
  bpl all_done                         ; Deal with false negatives.
  lda #1
all_done:
.endmacro

; eql_var_16
; Compare a 16 bit variable in memory with a value to see if they are equal.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The Z flag is set if var equals value.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of 0, 1..255, $100..$FF00
.macro eql_var_16 var, value
  .local not_equal
  .ifconst value                       ; Is value resolved at assembly time?
    .if value                          ; Is value non-zero?
      lda var

      .if .lobyte(value)               ; Is value low byte non-zero?
        cmp #.lobyte(value)
      .endif

      bne not_equal
      lda var+1

      .if .hibyte(value)               ; Is value high byte non-zero?
        cmp #.hibyte(value)
      .endif

    .else                              ; No, it is zero.
      lda var
      ora var+1
    .endif

  .else                                ; No, we need to compare both bytes.
    lda var
    cmp #.lobyte(value)
    bne not_equal
    lda var+1
    cmp #.hibyte(value)
  .endif

not_equal:
.end_macro

; eql_zpp_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer with a
; value to see if they are equal.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   value - an integer value to compare (zpp) with.
; Returns:
;   The Z flag is set if the 16 bit data at (zpp) equals value.
; Notes:
;   Clobbers the A and Y registers.
;   Optimized for special cases like values of 0, $00xx, $xx00.
.macro eql_zpp_16 zpp, value
  .local not_equal
  .ifconst value                       ; Is value resolved at assembly time?
    .if value                          ; Is value non-zero?
      lda (zpp)

      .if .lobyte(value)               ; Is value low byte non-zero?
        cmp #.lobyte(value)
      .endif

      bne not_equal
      ldy #1
      lda (zpp)

      .if .hibyte(value)               ; Is value high byte non-zero?
        cmp #.hibyte(value)
      .endif

    .else                              ; No, it is zero.
      lda (zpp)
      ldy #1
      ora (zpp),y
    .endif

  .else                                ; No, we need to compare both bytes.
    lda (zpp)
    cmp #.lobyte(value)
    bne not_equal
    ldy #1
    lda (zpp),y
    cmp #.hibyte(value)
  .endif

not_equal:
.endmacro

; eql_zpy_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register with a value to see if they are equal.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
;   value - an integer value to compare (zpp),y with.
; Returns:
;   The Z flag is set if the 16 bit data at (zpy),y equals value.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of 0 and $xx00.
;   Page wrap failure if Y == $FF on entry.
.macro eql_zpy_16 zpy, value
  .local not_equal
  .ifconst value                       ; Is value resolved at assembly time?
    .if value                          ; Is value non-zero?
      lda (zpy),y

      .if .lobyte(value)               ; Is value low byte non-zero?
        cmp #.lobyte(value)
      .endif

      bne not_equal
      iny #1
      lda (zpy),y
      dey
      cmp #.hibyte(value)

    .else                              ; No, it is zero.
      iny
      lda (zpy),y
      dey
      ora (zpy),y
    .endif

  .else                                ; No, we need to compare both bytes.
    iny
    lda (zpy),y
    dey
    cmp #.hibyte(value)
    bne not_equal
    lda (zpy),y
    cmp #.lobyte(value)
  .endif

not_equal:
.endmacro

; gte_var_16
; Compare a 16 bit variable in memory with a value to see if it is greater or equal.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The C and N flags are set if var is greater or equal to value.
;   C is set if var >= value using unsigned comparison.
;   N is cleared if var >= value using signed comparison.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
.macro gte_var_16 var, value
  sec

  .if (!.const(value))||.lobyte(value) ; Do we need to do all the work?
    lda var                            ; Get the low byte
    sbc #.lobyte(value)                ; Subtract it.
  .endif

  lda var+1
  sbc #.hibyte(value)
.endmacro

; gte_zpp_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer with
; a value to see if it is greater or equal.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   value - an integer value to compare (zpp) with.
; Returns:
;   The C and N flags are set if (zpp) is greater or equal to value.
;   C is set if (zpp) >= value using unsigned comparison.
;   N is cleared if (zpp) >= value using signed comparison.
; Notes:
;   Clobbers the A and Y registers.
;   Optimized for special cases like values of $xx00.
.macro gte_zpp_16 zpp, value
  sec

  .if (!.const(value))||.lobyte(value) ; Do we need to do all the work?
    lda (zpp)                          ; Yes; Get the low byte and
    sbc #.lobyte(value)                ; subtract from it.
  .endif

  ldy #1
  lda (zpp),y
  sbc #.hibyte(value)
.endmacro

; gte_zpy_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register with a value to see if it is greater or equal.
; Parameters:
;   zpy - a pointer in the zero page indexed by the Y register that points to a
;         16 bit variable. The Y register needs to be setup by the caller.
;   value - an integer value to compare var with.
; Returns:
;   The C and N flags are set if (zpy),y is greater or equal to value.
;   C is set if (zpy),y >= value using unsigned comparison.
;   N is cleared if (zpy),y >= value using signed comparison.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
;   Page wrap failure if Y == $FF on entry.
.macro gte_zpy_16 zpy, value
  sec                                  ; Before subtract, always set carry.

  .if (!.const(value))||.lobyte(value) ; Do we need to do all the work?
    lda (zpy),y                        ; Get the low byte
    sbc #.lobyte(value)                ; Subtract it.
  .endif

  iny
  lda (zpy),y                          ; Subtract the high byte.
  dey
  sbc #.hibyte(value)
.endmacro


; cmp_var_16
; Compare a 16 bit variable in memory with a value.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The V, C, N, and Z flags are set.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
.macro cmp_var_16 var, value
  .local not_equal
  .local all_done

  sec
  lda var                              ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  lda var+1                            ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  lda var+1                            ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

; cmp_zpp_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer
; with a value.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The V, C, N, and Z flags are set.
; Notes:
;   Clobbers the A and Y registers.
;   Optimized for special cases like values of $xx00.
.macro cmp_zpp_16 zpp, value
  .local not_equal
  .local all_done

  sec
  ldy #1
  lda (zpp)                            ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  lda (zpp),y                          ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  lda (zpp),y                          ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

; cmp_zpy_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register with a value.
; Parameters:
;   zpy - a pointer in the zero page indexed by the Y register that points to
;         a 16 bit variable.  The Y register needs to be setup by the caller.
;   value - an integer value to compare var with.
; Returns:
;   The V, C, N, and Z flags are set.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
;   Page wrap failure if Y == $FF on entry.
.macro cmp_zpy_16 zpy, value
  .local not_equal
  .local all_done

  sec
  lda (zpy),y                          ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  iny
  lda (zpy),y                          ; Get the high byte of data.
  dey
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  iny
  lda (zpy),y                          ; Get the high byte of data.
  dey
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro
