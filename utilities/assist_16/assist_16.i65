; Some 16 bit utility macros for the 65C02 processor.

; This is the top level include file that brings in all of the other include
; files. If finer grain control is desired, you can include files at a lower
; level. This is useful if only a few macros are required.

; The code contains safeguards against multiple file inclusion.

; Load up all of the subordinate files.

.include "set_16.i65"
.include "inc_16.i65"
.include "dec_16.i65"
.include "adj_16.i65"
.include "tst_16.i65"

; eql_var_16
; Compare a 16 bit variable in memory with a value to see if they are equal.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The Z flag is set if var equals value.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of 0, 1..255, $100..$FF00
.macro eql_var_16 var, value
  .local not_equal
  .ifconst value                       ; Is value resolved at assembly time?
    .if value                          ; Is value non-zero?
      lda var

      .if .lobyte(value)               ; Is value low byte non-zero?
        cmp #.lobyte(value)
      .endif

      bne not_equal
      lda var+1

      .if .hibyte(value)               ; Is value high byte non-zero?
        cmp #.hibyte(value)
      .endif

    .else                              ; No, it is zero.
      lda var
      ora var+1
    .endif

  .else                                ; No, we need to compare both bytes.
    lda var
    cmp #.lobyte(value)
    bne not_equal
    lda var+1
    cmp #.hibyte(value)
  .endif

not_equal:
.end_macro

; eql_zpp_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer with a
; value to see if they are equal.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   value - an integer value to compare (zpp) with.
; Returns:
;   The Z flag is set if the 16 bit data at (zpp) equals value.
; Notes:
;   Clobbers the A and Y registers.
;   Optimized for special cases like values of 0, $00xx, $xx00.
.macro eql_zpp_16 zpp, value
  .local not_equal
  .ifconst value                       ; Is value resolved at assembly time?
    .if value                          ; Is value non-zero?
      lda (zpp)

      .if .lobyte(value)               ; Is value low byte non-zero?
        cmp #.lobyte(value)
      .endif

      bne not_equal
      ldy #1
      lda (zpp)

      .if .hibyte(value)               ; Is value high byte non-zero?
        cmp #.hibyte(value)
      .endif

    .else                              ; No, it is zero.
      lda (zpp)
      ldy #1
      ora (zpp),y
    .endif

  .else                                ; No, we need to compare both bytes.
    lda (zpp)
    cmp #.lobyte(value)
    bne not_equal
    ldy #1
    lda (zpp),y
    cmp #.hibyte(value)
  .endif

not_equal:
.endmacro

; eql_zpy_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register with a value to see if they are equal.
; Parameters:
;   zpy - a pointer in the zero page, indexed by the Y register, that points to
;         a 16 bit variable. The Y register needs to be setup by the caller.
;   value - an integer value to compare (zpp),y with.
; Returns:
;   The Z flag is set if the 16 bit data at (zpy),y equals value.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of 0 and $xx00.
;   Page wrap failure if Y == $FF on entry.
.macro eql_zpy_16 zpy, value
  .local not_equal
  .ifconst value                       ; Is value resolved at assembly time?
    .if value                          ; Is value non-zero?
      lda (zpy),y

      .if .lobyte(value)               ; Is value low byte non-zero?
        cmp #.lobyte(value)
      .endif

      bne not_equal
      iny #1
      lda (zpy),y
      dey
      cmp #.hibyte(value)

    .else                              ; No, it is zero.
      iny
      lda (zpy),y
      dey
      ora (zpy),y
    .endif

  .else                                ; No, we need to compare both bytes.
    iny
    lda (zpy),y
    dey
    cmp #.hibyte(value)
    bne not_equal
    lda (zpy),y
    cmp #.lobyte(value)
  .endif

not_equal:
.endmacro

; gte_var_16
; Compare a 16 bit variable in memory with a value to see if it is greater or equal.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The C and N flags are set if var is greater or equal to value.
;   C is set if var >= value using unsigned comparison.
;   N is cleared if var >= value using signed comparison.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
.macro gte_var_16 var, value
  sec

  .if (!.const(value))||.lobyte(value) ; Do we need to do all the work?
    lda var                            ; Get the low byte
    sbc #.lobyte(value)                ; Subtract it.
  .endif

  lda var+1
  sbc #.hibyte(value)
.endmacro

; gte_zpp_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer with
; a value to see if it is greater or equal.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   value - an integer value to compare (zpp) with.
; Returns:
;   The C and N flags are set if (zpp) is greater or equal to value.
;   C is set if (zpp) >= value using unsigned comparison.
;   N is cleared if (zpp) >= value using signed comparison.
; Notes:
;   Clobbers the A and Y registers.
;   Optimized for special cases like values of $xx00.
.macro gte_zpp_16 zpp, value
  sec

  .if (!.const(value))||.lobyte(value) ; Do we need to do all the work?
    lda (zpp)                          ; Yes; Get the low byte and
    sbc #.lobyte(value)                ; subtract from it.
  .endif

  ldy #1
  lda (zpp),y
  sbc #.hibyte(value)
.endmacro

; gte_zpy_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register with a value to see if it is greater or equal.
; Parameters:
;   zpy - a pointer in the zero page indexed by the Y register that points to a
;         16 bit variable. The Y register needs to be setup by the caller.
;   value - an integer value to compare var with.
; Returns:
;   The C and N flags are set if (zpy),y is greater or equal to value.
;   C is set if (zpy),y >= value using unsigned comparison.
;   N is cleared if (zpy),y >= value using signed comparison.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
;   Page wrap failure if Y == $FF on entry.
.macro gte_zpy_16 zpy, value
  sec                                  ; Before subtract, always set carry.

  .if (!.const(value))||.lobyte(value) ; Do we need to do all the work?
    lda (zpy),y                        ; Get the low byte
    sbc #.lobyte(value)                ; Subtract it.
  .endif

  iny
  lda (zpy),y                          ; Subtract the high byte.
  dey
  sbc #.hibyte(value)
.endmacro


; cmp_var_16
; Compare a 16 bit variable in memory with a value.
; Parameters:
;   var  - the name of a zero page or absolute addressed 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The V, C, N, and Z flags are set.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
.macro cmp_var_16 var, value
  .local not_equal
  .local all_done

  sec
  lda var                              ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  lda var+1                            ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  lda var+1                            ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

; cmp_zpp_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer
; with a value.
; Parameters:
;   zpp - a pointer in the zero page that points to a 16 bit variable.
;   value - an integer value to compare var with.
; Returns:
;   The V, C, N, and Z flags are set.
; Notes:
;   Clobbers the A and Y registers.
;   Optimized for special cases like values of $xx00.
.macro cmp_zpp_16 zpp, value
  .local not_equal
  .local all_done

  sec
  ldy #1
  lda (zpp)                            ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  lda (zpp),y                          ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  lda (zpp),y                          ; Get the high byte of data.
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro

; cmp_zpy_16
; Compare a 16 bit variable in memory pointed to by a zero page pointer indexed
; by the Y register with a value.
; Parameters:
;   zpy - a pointer in the zero page indexed by the Y register that points to
;         a 16 bit variable.  The Y register needs to be setup by the caller.
;   value - an integer value to compare var with.
; Returns:
;   The V, C, N, and Z flags are set.
; Notes:
;   Clobbers the A register.
;   Optimized for special cases like values of $xx00.
;   Page wrap failure if Y == $FF on entry.
.macro cmp_zpy_16 zpy, value
  .local not_equal
  .local all_done

  sec
  lda (zpy),y                          ; Get the low byte of data.

  .if (!.const(value))||.lobyte(value) ; Can we skip the subtract?
    sbc #.lobyte(value)                ; Nope, gotta do the work!
  .endif

  bne not_equal                        ; Branch if low bytes not equal.

  iny
  lda (zpy),y                          ; Get the high byte of data.
  dey
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bra all_done

not_equal:                             ; Got here because low bytes not equal.
  iny
  lda (zpy),y                          ; Get the high byte of data.
  dey
  sbc #.hibyte(value)                  ; Subtract the high bytes.
  bne all_done                         ; If not zero we must skip over.
  inc                                  ; In this branch we must clear Z.

all_done:
.endmacro
