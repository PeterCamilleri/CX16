; SWEET-16 - The APPLE-II Pseudo Machine Interpreter
; Copyright (C) 1977 APPLE COMPUTER, INC -- All  Rights Reserved
; S. WOZNIAK
; Original code courtesy of: http://www.6502.org/source/interpreters/sweet16.htm
; Ported to ca65 for the Commander X 16 project by Peter Camilleri

.pc02                        ; Configure to use the W65C02S.

sweet_16_main_included = 1
.include "sweet_16.i65"      ; Include Sweet-16 declarations
.include "../utilities/assist_16/inc_16.i65" ; Grab 16 bit increment

.pushseg
.code

sw16:                        ; The Sweet-16 entry point
  sw16_save_all              ; Preserve 6502 reg contents

; Pop the 6502 PC into the sw16 PC
  pla
  sta  r15l
  pla
  sta  r15h

execute_loop:                ; The top level VM loop
  jsr  execute_one_instruction
  bra  execute_loop

execute_one_instruction:
  inc_16 r15                 ;Increment sweet16 PC for fetch


;        lda  >set           ;common high byte for all routines
;        pha                 ;push on stack for rts
;        ldy  $0
;        lda  (r15l),y       ;fetch instr
;        and  $f             ;mask reg specification
;        asl                 ;double for two byte registers
;        tax                 ;to x reg for indexing
;        lsr
;        eor  (r15l),y       ;now have opcode
;        beq  tobr           ;if zero then non-reg op
;        stx  r14h           ;indicate "prior result reg"
;        lsr
;        lsr                 ;opcode*2 to lsb's
;        lsr
;        tay                 ;to y reg for indexing
;        lda  optbl-2,y      ;low order adr byte
;        pha                 ;onto stack
;        rts                 ;goto reg-op routine
;
;tobr    inc  r15l
;        bne  tobr2          ;incr pc
;        inc  r15h
;tobr2   lda  brtbl,x        ;low order adr byte
;        pha                 ;onto stack for non-reg op
;        lda  r14h           ;"prior result reg" index
;        lsr                 ;prepare carry for bc, bnc.
;        rts                 ;goto non-reg op routine
;rtnz    pla                 ;pop return address
;        pla
  sw16_restore_all           ; Restore 6502 reg contents
;        jmp  (r15l)         ;return to 6502 code via pc
;
;setz    lda  (r15l),y       ;high order byte of constant
;        sta  r0h,x
;        dey
;        lda  (r15l),y       ;low order byte of constant
;        sta  r0l,x
;        tya                 ;y reg contains 1
;        sec
;        adc  r15l           ;add 2 to pc
;        sta  r15l
;        bcc  set2
;        inc  r15h
;set2    rts
;
;optbl   dfb  set-1          ;1x
;brtbl   dfb  rtn-1          ;0
;        dfb  ld-1           ;2x
;        dfb  br-1           ;1
;        dfb  st-1           ;3x
;        dfb  bnc-1          ;2
;        dfb  ldat-1         ;4x
;        dfb  bc-1           ;3
;        dfb  stat-1         ;5x
;        dfb  bp-1           ;4
;        dfb  lddat-1        ;6x
;        dfb  bm-1           ;5
;        dfb  stdat-1        ;7x
;        dfb  bz-1           ;6
;        dfb  pop-1          ;8x
;        dfb  bnz-1          ;7
;        dfb  stpat-1        ;9x
;        dfb  bm1-1          ;8
;        dfb  add-1          ;ax
;        dfb  bnm1-1         ;9
;        dfb  sub-1          ;bx
;        dfb  bk-1           ;a
;        dfb  popd-1         ;cx
;        dfb  rs-1           ;b
;        dfb  cpr-1          ;dx
;        dfb  bs-1           ;c
;        dfb  inr-1          ;ex
;        dfb  nul-1          ;d
;        dfb  dcr-1          ;fx
;        dfb  nul-1          ;e
;        dfb  nul-1          ;unused
;        dfb  nul-1          ;f
;
;* following code must be
;* contained on a single page!
;
;set     bpl  setz           ;always taken
;ld      lda  r0l,x
;bk      equ  *-1
;        sta  r0l
;        lda  r0h,x          ;move rx to r0
;        sta  r0h
;        rts
;st      lda  r0l
;        sta  r0l,x          ;move r0 to rx
;        lda  r0h
;        sta  r0h,x
;        rts
;stat    lda  r0l
;stat2   sta  (r0l,x)        ;store byte indirect
;        ldy  $0
;stat3   sty  r14h           ;indicate r0 is result neg
;inr     inc  r0l,x
;        bne  inr2           ;incr rx
;        inc  r0h,x
;inr2    rts
;ldat    lda  (r0l,x)        ;load indirect (rx)
;        sta  r0l            ;to r0
;        ldy  $0
;        sty  r0h            ;zero high order r0 byte
;        beq  stat3          ;always taken
;pop     ldy  $0             ;high order byte = 0
;        beq  pop2           ;always taken
;popd    jsr  dcr            ;decr rx
;        lda  (r0l,x)        ;pop high order byte @rx
;        tay                 ;save in y reg
;pop2    jsr  dcr            ;decr rx
;        lda  (r0l,x)        ;low order byte
;        sta  r0l            ;to r0
;        sty  r0h
;pop3    ldy  $0             ;indicate r0 as last result reg
;        sty  r14h
;        rts
;lddat   jsr  ldat           ;low order byte to r0, incr rx
;        lda  (r0l,x)        ;high order byte to r0
;        sta  r0h
;        jmp  inr            ;incr rx
;stdat   jsr  stat           ;store indirect low order
;        lda  r0h            ;byte and incr rx. then
;        sta  (r0l,x)        ;store high order byte.
;        jmp  inr            ;incr rx and return
;stpat   jsr  dcr            ;decr rx
;        lda  r0l
;        sta  (r0l,x)        ;store r0 low byte @rx
;        jmp  pop3           ;indicate r0 as last result reg
;dcr     lda  r0l,x
;        bne  dcr2           ;decr rx
;        dec  r0h,x
;dcr2    dec  r0l,x
;        rts
;sub     ldy  $0             ;result to r0
;        cpr  sec            ;note y reg = 13*2 for cpr
;        lda  r0l
;        sbc  r0l,x
;        sta  r0l,y          ;r0-rx to ry
;        lda  r0h
;        sbc  r0h,x
;sub2    sta  r0h,y
;        tya                 ;last result reg*2
;        adc  $0             ;carry to lsb
;        sta  r14h
;        rts
;add     lda  r0l
;        adc  r0l,x
;        sta  r0l            ;r0+rx to r0
;        lda  r0h
;        adc  r0h,x
;        ldy  $0             ;r0 for result
;        beq  sub2           ;finish add
;bs      lda  r15l           ;note x reg is 12*2!
;        jsr  stat2          ;push low pc byte via r12
;        lda  r15h
;        jsr  stat2          ;push high order pc byte
;br      clc
;bnc     bcs  bnc2           ;no carry test
;br1     lda  (r15l),y       ;displacement byte
;        bpl  br2
;        dey
;br2     adc  r15l           ;add to pc
;        sta  r15l
;        tya
;        adc  r15h
;        sta  r15h
;bnc2    rts
;bc      bcs  br
;        rts
;bp      asl                 ;double result-reg index
;        tax                 ;to x reg for indexing
;        lda  r0h,x          ;test for plus
;        bpl  br1            ;branch if so
;        rts
;bm      asl                 ;double result-reg index
;        tax
;        lda  r0h,x          ;test for minus
;        bmi  br1
;        rts
;bz      asl                 ;double result-reg index
;        tax
;        lda  r0l,x          ;test for zero
;        ora  r0h,x          ;(both bytes)
;        beq  br1            ;branch if so
;        rts
;bnz     asl                 ;double result-reg index
;        tax
;        lda  r0l,x          ;test for non-zero
;        ora  r0h,x          ;(both bytes)
;        bne  br1            ;branch if so
;        rts
;bm1     asl                 ;double result-reg index
;        tax
;        lda  r0l,x          ;check both bytes
;        and  r0h,x          ;for $ff (minus 1)
;        eor  $ff
;        beq  br1            ;branch if so
;        rts
;bnm1    asl                 ;double result-reg index
;        tax
;        lda  r0l,x
;        and  r0h,x          ;check both bytes for no $ff
;        eor  $ff
;        bne  br1            ;branch if not minus 1
;nul     rts
;rs      ldx  $18            ;12*2 for r12 as stack pointer
;        jsr  dcr            ;decr stack pointer
;        lda  (r0l,x)        ;pop high return address to pc
;        sta  r15h
;        jsr  dcr            ;same for low order byte
;        lda  (r0l,x)
;        sta  r15l
;        rts
;rtn     jmp  rtnz
;
.popseg
