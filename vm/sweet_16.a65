; SWEET-16 - The APPLE-II Pseudo Machine Interpreter
; Copyright (C) 1977 APPLE COMPUTER, INC -- All  Rights Reserved
; S. WOZNIAK
; Original code courtesy of: http://www.6502.org/source/interpreters/sweet16.htm
; Ported to ca65 for the Commander X 16 project by Peter Camilleri

.pc02                        ; Configure to use the W65C02S.

sweet_16_main_included = 1
.include "sweet_16.i65"      ; Include Sweet-16 declarations
.include "../utilities/assist_16/inc_16.i65" ; Grab 16 bit increment

.pushseg
.code

sw16:                        ; The Sweet-16 entry point
  sw16_save_all              ; Preserve 6502 reg contents

; Pop the 6502 PC into the sw16 PC
  pla
  sta  r15l
  pla
  sta  r15h

execute_loop:                ; The top level VM loop
  jsr  execute_one_instruction
  bra  execute_loop

execute_one_instruction:
  inc_16 r15                 ; Increment sweet16 PC for fetch
  lda  #>sw16_page_start     ; Get the common high byte for all routines
  pha                        ; Push onto stack for clever jump-by-return trick
  ldy  #$0
  lda  (r15),y               ; Fetch the instruction
  and  #$0F                  ; Mask the register field
  asl                        ; Double for two byte registers
  tax                        ; Move to x reg for indexing

  lsr                        ; Restore the register field
  eor  (r15l),y              ; Now have isolated the opcode
  beq  non_register_op       ; If zero then it's a non-reg operation

;register_op
  stx  r14h                  ; Save the register as the "prior result reg"
  lsr                        ; Op field is opcode*16 so compute opcode*2
  lsr
  lsr
  tay                        ; Y = opcode*2 for indexing
  lda  op_code_table-2,y     ; Fetch OpCodeTable[(op+code-1)*2]
  pha                        ; and push it onto stack
  rts                        ; The infamous jump by returning

non_register_op:
  inc_16 r15                 ; Increment sweet16 PC for post-byte
  lda  non_reg_table,x       ; Get low order address byte
  pha                        ; onto stack for non-reg operations
  lda  r14h                  ; Get "prior result reg" index
  lsr                        ; Prepare carry for bc, bnc.
  rts                        ; Another infamous jump by returning


rtnz:
  pla                        ; Drop the return address.
  pla
  sw16_restore_all           ; Restore 6502 reg contents
  jmp  (r15l)                ; Return to 6502 code via R15 (PC)

setz:
  lda  (r15),y               ; Get the high order byte of the constant.
  sta  r0h,x
  dey
  lda  (r15l),y              ; Get the low order byte of the constant.
  sta  r0l,x
  tya                        ; The Y register now contains 1.
  sec                        ; Add 2 to R15 (PC).
  adc  r15l
  sta  r15l
  bcc  set2
  inc  r15h

set2:
  rts
;
op_code_table:
  .byte  <(set-1)            ; $1x SET  -- Load Register Immediate Word
non_reg_table:
  .byte  <(bk-1)             ; $00 BRK  -- Invoke the brk Interrupt. (NOP)
  .byte  <(ld-1)             ; $2x LD   -- Transfer Word Register to Accumulator
  .byte  <(br-1)             ; $01 BR   -- Branch
  .byte  <(st-1)             ; $3x ST   -- Transfer Word Accumulator to Register
  .byte  <(bnc-1)            ; $02 BNC  -- Branch If Carry Clear
  .byte  <(ldat-1)           ; $4x LD@  -- Transfer Memory Byte to Accumulator
  .byte  <(bc-1)             ; $03 BC   -- Branch If Carry Set
  .byte  <(stat-1)           ; $5x ST@  -- Transfer Accumulator Byte to Memory
  .byte  <(bp-1)             ; $04 BP   -- Branch If Positive
  .byte  <(lddat-1)          ; $6x LDD@ -- Transfer Memory Word to Accumulator
  .byte  <(bm-1)             ; $05 BM   -- Branch If Negative
  .byte  <(stdat-1)          ; $7x STD@ -- Transfer Accumulator Word to Memory
  .byte  <(bz-1)             ; $06 BZ   -- Branch If Zero
  .byte  <(pop-1)            ; $8x POP@ -- Transfer Memory Byte to Accumulator
  .byte  <(bnz-1)            ; $07 BZ   -- Branch If Zero
  .byte  <(stpat-1)          ; $9x STP@ -- Transfer Accumulator Byte to Memory
  .byte  <(bm1-1)            ; $08 BM1  -- Branch If Minus One
  .byte  <(add-1)            ; $ax ADD  -- Add Word Register to the Accumulator
; .byte  <(bnm1-1)             ; $09
  .byte  <(sub-1)            ; $bx SUB  -- Subtract Word Register from the Accumulator
; .byte  <(nul-1)              ; $0a
  .byte  <(popd-1)           ; $cx POPD@-- Transfer Memory Word to Accumulator
; .byte  <(rs-1)               ; $0b
; .byte  <(cpr-1)              ; $dx
; .byte  <(bs-1)               ; $0c
  .byte  <(inr-1)            ; $ex INR  -- Increment Word Register
; .byte  <(nul-1)              ; $0d
  .byte  <(dcr-1)            ; $fx DCR  -- Decrement Word Register
; .byte  <(nul-1)              ; $0e
; .byte  <(nul-1)              ; Unused
; .byte  <(nul-1)              ; $0f
;

; The following code must be contained in a single page!
.segment "SW16_PAGE": absolute
.align 256

sw16_page_start:             ; Start of page with SW16 code methods

set:                         ; Load Register Immediate Word
  jmp  setz                  ; Jump back to leave more space in this page

ld:
  lda  r0l,x                 ; Move Rx to R0
  sta  r0l
  lda  r0h,x
  sta  r0h
; fall through

bk:
  rts

st:
  lda  r0l                   ; Move R0 to Rx
  sta  r0l,x
  lda  r0h
  sta  r0h,x
  rts

stat:
  lda  r0l
stat2:
  sta  (r0l,x)               ; Store byte indirect.
  ldy  $0                    ; Indicate that R0 is the result register.
stat3:
  sty  r14h                  ; Update the status register.
  ; Fall through

inr:
  inc  r0l,x                 ; Increment Rx
  bne  inr2
  inc  r0h,x
inr2:
  rts

ldat:
  lda  (r0l,x)               ; Load indirect (Rx)
  sta  r0l                   ; to R0
  ldy  $0                    ; Zero pad the high order byte of R0
  sty  r0h
  bra  stat3                 ; Finish by updating the status

pop:
  ldy  $0                    ; High order byte = 0
  bra  pop2
popd:
  jsr  dcr                   ; Decrement Rx
  lda  (r0l,x)               ; Pop high order byte @Rx
  tay                        ; Save A in Y register
pop2:
  jsr  dcr                   ; Decrement Rx
  lda  (r0l,x)               ; Low order byte
  sta  r0l                   ; to R0
  sty  r0h
pop3:
  ldy  $0                    ; Indicate r0 as last result reg
  sty  r14h
  rts

lddat:
  jsr  ldat                  ; Low order byte to r0, incr rx
  lda  (r0l,x)               ; High order byte to r0
  sta  r0h
  jmp  inr                   ; Increment Rx

stdat:
  jsr  stat                  ; Store indirect low byte of R0
  lda  r0h                   ; byte and incr rx. then
  sta  (r0l,x)               ; store high order byte.
  jmp  inr                   ; Increment Rx and Return

stpat:
  jsr  dcr                   ; Decrement Rx
  lda  r0l
  sta  (r0l,x)               ; Store R0 low byte @Rx
  jmp  pop3                  ; Indicate R0 as last result reg

dcr:
  lda  r0l,x                 ; Decrement Rx
  bne  dcr2
  dec  r0h,x
dcr2:
  dec  r0l,x
  rts

sub:
  ldy  $0                    ; Y points result to R0
cpr:
  sec                        ; Y points result to R13 for cpr
  lda  r0l
  sbc  r0l,x                 ; R[y] = R0 - Rx
  sta  r0l,y
  lda  r0h
  sbc  r0h,x
sub2:                        ; Shared code for setting status info.
  sta  r0h,y
  tya                        ; Last result reg*2
  adc  $0                    ; Transfer the carry to LSB of A
  sta  r14h                  ; Save the status info
  rts

add:
  lda  r0l                   ; R0 = R0 + Rx
  adc  r0l,x
  sta  r0l
  lda  r0h
  adc  r0h,x
  ldy  $0                   ; R0 for result
  bra  sub2                 ; Finish add by setting status info.

;bs      lda  r15l           ;note x reg is 12*2!
;        jsr  stat2          ;push low pc byte via r12
;        lda  r15h
;        jsr  stat2          ;push high order pc byte

br:
  clc
  ; fall through

bnc:
  bcs  bnc2                  ; Skip if carry set.
br1:
  lda  (r15l),y              ; Get the displacement byte.
  bpl  br2
  dey                        ; Set Y to $FF for negative displacement byte.
br2:
  adc  r15l                  ; Add to R15 (PC)
  sta  r15l
  tya
  adc  r15h
  sta  r15h
bnc2:
  rts

bc:
  bcs  br
  rts

bp:
  asl                        ; Double the result register's index.
  tax                        ; into X reg for indexing
  lda  r0h,x                 ; Test for a positive value
  bpl  br1                   ; Branch if so
  rts

bm:
  asl                        ; Double the result register's index.
  tax
  lda  r0h,x                 ; Test for a negative value
  bmi  br1
  rts

bz:
  asl                        ; Double the result register's index.
  tax
  lda  r0l,x                 ; Test both bytes for zero
  ora  r0h,x
  beq  br1                   ; Branch if so
  rts

bnz:
  asl                        ; Double the result register's index.
  tax
  lda  r0l,x                 ; Test both byte for non-zero
  ora  r0h,x
  bne  br1                   ; Branch if so
  rts

bm1:
  asl                        ; Double the result register's index.
  tax
  lda  r0l,x                 ; Check both bytes for $FF (minus 1)
  and  r0h,x
  eor  $ff
  beq  br1                   ; Branch if so
  rts

;bnm1    asl                 ;double result-reg index
;        tax
;        lda  r0l,x
;        and  r0h,x          ;check both bytes for no $ff
;        eor  $ff
;        bne  br1            ;branch if not minus 1
;nul     rts

;rs      ldx  $18            ;12*2 for r12 as stack pointer
;        jsr  dcr            ;decr stack pointer
;        lda  (r0l,x)        ;pop high return address to pc
;        sta  r15h
;        jsr  dcr            ;same for low order byte
;        lda  (r0l,x)
;        sta  r15l
;        rts

rtn:
  jmp  rtnz

.popseg
