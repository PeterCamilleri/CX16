; SWEET-16 - The APPLE-II Pseudo Machine Interpreter
; Copyright (C) 1977 APPLE COMPUTER, INC -- All  Rights Reserved
; S. WOZNIAK
; Original code courtesy of: http://www.6502.org/source/interpreters/sweet16.htm
; Ported to ca65 for the Commander X 16 project by Peter Camilleri

.pc02                        ; Configure to use the W65C02S.

sweet_16_main_included = 1
.include "sweet_16.i65"      ; Include Sweet-16 declarations
.include "../utilities/assist_16/inc_16.i65" ; Grab 16 bit increment

.pushseg
.code

sw16:                        ; The Sweet-16 entry point
  sw16_save_all              ; Preserve 6502 reg contents

; Pop the 6502 PC into the sw16 PC
  pla
  sta  sw16_r15l
  pla
  sta  sw16_r15h

execute_loop:                ; The top level VM loop
  jsr  execute_one_instruction
  bra  execute_loop

execute_one_instruction:
  jsr inc_R15                ; Increment sweet16 PC for fetch
  lda  #>sw16_page_start     ; Get the common high byte for all routines
  pha                        ; Push onto stack for clever jump-by-return trick
  ldy  #$0
  lda  (sw16_r15),y          ; Fetch the instruction
  and  #$0F                  ; Mask the register field
  asl                        ; Double for two byte registers
  tax                        ; Move to x reg for indexing
  lsr                        ; Restore the register field
  eor  (sw16_r15),y          ; Now have isolated the opcode
  beq  non_register_op       ; If zero then it's a non-reg operation

;register_op
  stx  sw16_r14h             ; Save the register as the "prior result reg"
  lsr                        ; Op field is opcode*16 so compute opcode*2
  lsr
  lsr
  tay                        ; Y = opcode*2 for indexing
  lda  op_code_table,y       ; Fetch OpCodeTable[Y]
  pha                        ; and push it onto stack
  rts                        ; The infamous jump by returning

non_register_op:
  jsr inc_R15                ; Increment sweet16 PC for post-byte
  lda  non_reg_table,x       ; Get low order address byte
  pha                        ; onto stack for non-reg operations
  lda  sw16_r14h             ; Get "prior result reg" index
  lsr                        ; Prepare carry for bc, bnc.
  rts                        ; Another infamous jump by returning

op_code_table:
  .byte  <(nul-1)            ; $0x Unused - Non-register ops
non_reg_table:
  .byte  <(rtn-1)            ; $00 RTN  -- Resume 6502 Native Code
  .byte  <(set-1)            ; $1x SET  -- Load Register Immediate Word
  .byte  <(br-1)             ; $01 BR   -- Branch
  .byte  <(ld-1)             ; $2x LD   -- Transfer Word Register to R0
  .byte  <(bnc-1)            ; $02 BNC  -- Branch If Carry Clear
  .byte  <(st-1)             ; $3x ST   -- Transfer Word R0 to Register
  .byte  <(bc-1)             ; $03 BC   -- Branch If Carry Set
  .byte  <(ldat-1)           ; $4x LD@  -- Transfer Memory Byte to R0
  .byte  <(bp-1)             ; $04 BP   -- Branch If Positive
  .byte  <(stat-1)           ; $5x ST@  -- Transfer R0 Byte to Memory
  .byte  <(bm-1)             ; $05 BM   -- Branch If Negative
  .byte  <(lddat-1)          ; $6x LDD@ -- Transfer Memory Word to R0
  .byte  <(bz-1)             ; $06 BZ   -- Branch If Zero
  .byte  <(stdat-1)          ; $7x STD@ -- Transfer R0 Word to Memory
  .byte  <(bnz-1)            ; $07 BZ   -- Branch If Zero
  .byte  <(pop-1)            ; $8x POP@ -- Transfer Memory Byte to R0
  .byte  <(bm1-1)            ; $08 BM1  -- Branch If Minus One
  .byte  <(stpat-1)          ; $9x STP@ -- Transfer R0 Byte to Memory
  .byte  <(bnm1-1)           ; $09 BM1  -- Branch If Minus One
  .byte  <(add-1)            ; $Ax ADD  -- Add Word Register to the R0
  .byte  <(nul-1)            ; $0A BRK  -- Invoke the brk Interrupt. (NOP)
  .byte  <(sub-1)            ; $Bx SUB  -- Subtract Word Register from R0
  .byte  <(rs-1)             ; $0B RS   -- Return from a Subroutine
  .byte  <(popd-1)           ; $Cx POPD@-- Transfer Memory Word to R0
  .byte  <(bs-1)             ; $0C BS   -- Branch to a Subroutine
  .byte  <(cpr-1)            ; $Dx CPR  -- Compare Word Register with R0
  .byte  <(js-1)             ; $0D JS   -- Jump to a Subroutine
  .byte  <(inr-1)            ; $Ex INR  -- Increment Word Register
  .byte  <(nul-1)            ; $0E Reserved (NOP)
  .byte  <(dcr-1)            ; $Fx DCR  -- Decrement Word Register
  .byte  <(exs-1)            ; $0F EXS  -- Exit Simulation

; The following code must be contained in a single page! Well not the code
; really, just the labels of the op-code handlers.
.segment "PAGE_CODE":absolute
.align 256

sw16_page_start:             ; Start of page with SW16 code methods.

  .byte $00                  ; Padding because the jmp by rts trick is buggy.
                             ; It does not handle page backsliding. On the
                             ; other hand the last table target CAN be past
                             ; the end of the page by exactly one byte.

set:                         ; Load Register Immediate Word
  jmp  do_set                ; Moved the code to leave more space in this page.

ld:
  lda  sw16_r0l,x            ; Move Rx to R0.
  sta  sw16_r0l
  lda  sw16_r0h,x
  sta  sw16_r0h
; fall through

nul:
bk:
  rts

st:
  lda  sw16_r0l              ; Move R0 to Rx.
  sta  sw16_r0l,x
  lda  sw16_r0h
  sta  sw16_r0h,x
  rts

stat:
  lda  sw16_r0l
stat2:
  sta  (sw16_regs,x)         ; Store byte indirect.
stat3:
  stz  sw16_r14h             ; Indicate that R0 is the result register.
  ; Fall through

inr:
  inc  sw16_r0l,x            ; Increment Rx.
  bne  inr2
  inc  sw16_r0h,x
inr2:
  rts

ldat:
  lda  (sw16_r0l,x)          ; Load indirect (Rx)
  sta  sw16_r0l              ; to R0.
  stz  sw16_r0h              ; Zero pad the high order byte of R0.
  bra  stat3                 ; Finish by updating the status.

pop:
  ldy  #$0                   ; High order byte = 0
  bra  pop2
popd:
  jsr  dcr                   ; Decrement Rx.
  lda  (sw16_r0l,x)          ; Pop high order byte @Rx.
  tay                        ; Save A in Y register.
pop2:
  jsr  dcr                   ; Decrement Rx.
  lda  (sw16_r0l,x)          ; Low order byte.
  sta  sw16_r0l              ; to R0.
  sty  sw16_r0h
pop3:
  stz  sw16_r14h             ; Indicate R0 as last result reg.
  rts

lddat:
  jsr  ldat                  ; Low order byte to r0, increment rx
  lda  (sw16_r0l,x)          ; High order byte to r0
  sta  sw16_r0h
  jmp  inr                   ; Increment Rx

stdat:
  jsr  stat                  ; Store indirect low byte of R0
  lda  sw16_r0h              ; Then store high order byte.
  sta  (sw16_r0l,x)
  jmp  inr                   ; Increment Rx and Return

stpat:
  jsr  dcr                   ; Decrement Rx
  lda  sw16_r0l              ; Store R0 low byte @Rx
  sta  (sw16_r0l,x)
  jmp  pop3                  ; Indicate R0 as last result reg

dcr:
  lda  sw16_r0l,x            ; Decrement Rx
  bne  dcr2
  dec  sw16_r0h,x
dcr2:
  dec  sw16_r0l,x
  rts

sub:
  ldy  #$0                   ; Y points result to R0
cpr:
  sec                        ; Y points result to R13 for cpr
  lda  sw16_r0l              ; R[y] = R0 - Rx
  sbc  sw16_r0l,x
  sta  sw16_r0l,y
  lda  sw16_r0h
  sbc  sw16_r0h,x
sub2:                        ; Shared code for setting status info.
  sta  sw16_r0h,y
  tya                        ; Last result reg*2
  adc  #$0                   ; Transfer the carry to LSB of A
  sta  sw16_r14h             ; Save the status info
  rts

add:
  lda  sw16_r0l              ; R0 = R0 + Rx
  adc  sw16_r0l,x
  sta  sw16_r0l
  lda  sw16_r0h
  adc  sw16_r0h,x
  ldy  #$0                   ; R0 for result
  bra  sub2                  ; Finish add by setting status info.

bs:
  lda  sw16_r15l             ; Note x reg is r12_offset (12*2)!
  jsr  stat2                 ; Push low PC byte via R12
  lda  sw16_r15h
  jsr  stat2                 ; Push high order PC byte
  ; fall through

br:
  clc
  ; fall through

bnc:
  bcs  bnc2                  ; Skip if carry set.
br1:
  lda  (sw16_r15l),y         ; Get the displacement byte.
  bpl  br2
  dey                        ; Set Y to $FF for negative displacement byte.
br2:
  adc  sw16_r15l             ; Add to R15 (PC)
  sta  sw16_r15l
  tya
  adc  sw16_r15h
  sta  sw16_r15h
bnc2:
  rts

bc:
  bcs  br
  rts

bp:
  asl                        ; Double the result register's index.
  tax                        ; into X reg for indexing
  lda  sw16_r0h,x            ; Test for a positive value
  bpl  br1                   ; Branch if so
  rts

bm:
  asl                        ; Double the result register's index.
  tax
  lda  sw16_r0h,x            ; Test for a negative value
  bmi  br1
  rts

bz:
  asl                        ; Double the result register's index.
  tax
  lda  sw16_r0l,x            ; Test both bytes for zero
  ora  sw16_r0h,x
  beq  br1                   ; Branch if so
  rts

bnz:
  asl                        ; Double the result register's index.
  tax
  lda  sw16_r0l,x            ; Test both byte for non-zero
  ora  sw16_r0h,x
  bne  br1                   ; Branch if so
  rts

bm1:
  asl                        ; Double the result register's index.
  tax
  lda  sw16_r0l,x            ; Check both bytes for $FF (minus 1)
  and  sw16_r0h,x
  eor  $ff
  beq  br1                   ; Branch if minus 1
  rts

bnm1:
  asl                        ; Double the result register's index.
  tax
  lda  sw16_r0l,x
  and  sw16_r0h,x            ; Check both bytes for no $FF
  eor  $ff
  bne  br1                   ; Branch if not minus 1
  rts

rs:
  ldx  #sw16_r12_offset      ; X contains the offset of R12 (SP).
  jsr  dcr                   ; Decrement the SP
  lda  (sw16_r0l,x)          ; Pop high return address to R15 (PC)
  sta  sw16_r15h
  jsr  dcr                   ; Same for low order byte
  lda  (sw16_r0l,x)
  sta  sw16_r15l
  rts

rtn:
  jmp do_rtn                 ; Continue in the standard code segment.

js:
  jmp do_js

exs:                         ; Option simulator support
  jmp do_exit_sim


.code
; Code moved out of the PAGE_CODE segment to keep it under one page in length.

do_rtn:
  pla                        ; Drop the return address.
  pla
  sw16_restore_all           ; Restore 6502 reg contents
  jmp  (sw16_r15)            ; Return to 6502 code via R15 (PC)

do_set:
  jsr  inc_R15               ; Step to the low order constant byte.
  lda  (sw16_r15)            ; Get the low order byte of the constant.
  tay                        ; Hide it for now
  jsr  inc_R15               ; Step to the high order constant byte.
  lda  (sw16_r15)            ; Get the high order byte of the constant.
  sta  sw16_r0h,x            ; Store the high byte
  tya                        ; The low byte comes out of hiding.
  sta  sw16_r0l,x            ; Store the high byte
  rts

; Increment the PC (R15)
inc_R15:
  inc_16 sw16_r15
  rts

do_js:
  lda  (sw16_r15)            ; Get the low order byte of the target.
  tay                        ; Hide it!
  jsr  inc_R15               ; Step to the high order target address.

  ; Push the PC onto the stack.
  ldx  #sw16_r12_offset      ; Set X to the R12 offset for incrementing.
  lda  sw16_r15l             ; Get PC low byte.
  jsr  stat2                 ; Store it and increment the SP.
  lda  sw16_r15h             ; Get PC high byte.
  jsr  stat2                 ; Store it and increment the SP.

  ; Update the PC
  lda  (sw16_r15)            ; Get the target high address.
  sty  sw16_r15l
  sta  sw16_r15h

  rts

; Support for testing with the sim65 simulator.
do_exit_sim:
.ifdef sw16_sim_support
  lda  (sw16_r15)            ; Fetch the exit code.
  jmp exit                   ; Exit the simulation.
.else
  rts                        ; Else if no sim support, do nothing.
.endif

.popseg
