; SWEET-16 - The APPLE-II Pseudo Machine Interpreter
; Copyright (C) 1977 APPLE COMPUTER, INC -- All  Rights Reserved
; S. WOZNIAK
; Original code courtesy of: http://www.6502.org/source/interpreters/sweet16.htm
; Ported to ca65 for the Commander X 16 project by Peter Camilleri

.pc02                        ; Configure to use the W65C02S.

sweet_16_main_included = 1
.include "sweet_16.i65"      ; Include Sweet-16 declarations
.include "../utilities/assist_16/inc_16.i65" ; Grab 16 bit increment

.pushseg
.code

sw16:                        ; The Sweet-16 entry point
  sw16_save_all              ; Preserve 6502 reg contents

; Pop the 6502 PC into the sw16 PC
  pla
  sta  r15l
  pla
  sta  r15h

execute_loop:                ; The top level VM loop
  jsr  execute_one_instruction
  bra  execute_loop

execute_one_instruction:
  inc_16 r15                 ; Increment sweet16 PC for fetch
  lda  #>sw16_page_start     ; Get the common high byte for all routines
  pha                        ; Push onto stack for clever jump-by-return trick
  ldy  #$0
  lda  (r15),y               ; Fetch the instruction
  and  #$0F                  ; Mask the register field
  asl                        ; Double for two byte registers
  tax                        ; Move to x reg for indexing

  lsr                        ; Restore the register field
  eor  (r15l),y              ; Now have isolated the opcode
  beq  non_register_op       ; If zero then it's a non-reg operation

;register_op
  stx  r14h                  ; Save the register as the "prior result reg"
  lsr                        ; Op field is opcode*16 so compute opcode*2
  lsr
  lsr
  tay                        ; Y = opcode*2 for indexing
  lda  op_code_table-2,y     ; Fetch OpCodeTable[(op+code-1)*2]
  pha                        ; and push it onto stack
  rts                        ; The infamous jump by returning

non_register_op:
  inc_16 r15                 ; Increment sweet16 PC for post-byte
  lda  non_reg_table,x       ; Get low order address byte
  pha                        ; onto stack for non-reg operations
  lda  r14h                  ; Get "prior result reg" index
  lsr                        ; Prepare carry for bc, bnc.
  rts                        ; Another infamous jump by returning


;rtnz    pla                 ;pop return address
;        pla
  sw16_restore_all           ; Restore 6502 reg contents
;        jmp  (r15l)         ;return to 6502 code via pc
;
;setz:    lda  (r15),y       ;high order byte of constant
;        sta  r0h,x
;        dey
;        lda  (r15l),y       ;low order byte of constant
;        sta  r0l,x
;        tya                 ;y reg contains 1
;        sec
;        adc  r15l           ;add 2 to pc
;        sta  r15l
;        bcc  set2
;        inc  r15h
;set2    rts
;
op_code_table:
; .byte  <(set-1)              ; $1x
non_reg_table:
; .byte  <(rtn-1)              ; $00
; .byte  <(ld-1)               ; $2x
; .byte  <(br-1)               ; $01
; .byte  <(st-1)               ; $3x
; .byte  <(bnc-1)              ; $02
; .byte  <(ldat-1)             ; $4x
; .byte  <(bc-1)               ; $03
; .byte  <(stat-1)             ; $5x
; .byte  <(bp-1)               ; $04
; .byte  <(lddat-1)            ; $6x
; .byte  <(bm-1)               ; $05
; .byte  <(stdat-1)            ; $7x
; .byte  <(bz-1)               ; $06
; .byte  <(pop-1)              ; $8x
; .byte  <(bnz-1)              ; $07
; .byte  <(stpat-1)            ; $9x
; .byte  <(bm1-1)              ; $08
; .byte  <(add-1)              ; $ax
; .byte  <(bnm1-1)             ; $09
; .byte  <(sub-1)              ; $bx
; .byte  <(bk-1)               ; $0a
; .byte  <(popd-1)             ; $cx
; .byte  <(rs-1)               ; $0b
; .byte  <(cpr-1)              ; $dx
; .byte  <(bs-1)               ; $0c
; .byte  <(inr-1)              ; $ex
; .byte  <(nul-1)              ; $0d
; .byte  <(dcr-1)              ; $fx
; .byte  <(nul-1)              ; $0e
; .byte  <(nul-1)              ; Unused
; .byte  <(nul-1)              ; $0f
;

; The following code must be contained in a single page!
.segment "SW16_PAGE": absolute
.align 256

sw16_page_start:              ; Start of page with SW16 code methods

;set:     jmp  setz           ; Jump back to leave more space in this page
;ld      lda  r0l,x
;bk      equ  *-1
;        sta  r0l
;        lda  r0h,x          ;move rx to r0
;        sta  r0h
;        rts
;st      lda  r0l
;        sta  r0l,x          ;move r0 to rx
;        lda  r0h
;        sta  r0h,x
;        rts
;stat    lda  r0l
;stat2   sta  (r0l,x)        ;store byte indirect
;        ldy  $0
;stat3   sty  r14h           ;indicate r0 is result neg
;inr     inc  r0l,x
;        bne  inr2           ;incr rx
;        inc  r0h,x
;inr2    rts
;ldat    lda  (r0l,x)        ;load indirect (rx)
;        sta  r0l            ;to r0
;        ldy  $0
;        sty  r0h            ;zero high order r0 byte
;        beq  stat3          ;always taken
;pop     ldy  $0             ;high order byte = 0
;        beq  pop2           ;always taken
;popd    jsr  dcr            ;decr rx
;        lda  (r0l,x)        ;pop high order byte @rx
;        tay                 ;save in y reg
;pop2    jsr  dcr            ;decr rx
;        lda  (r0l,x)        ;low order byte
;        sta  r0l            ;to r0
;        sty  r0h
;pop3    ldy  $0             ;indicate r0 as last result reg
;        sty  r14h
;        rts
;lddat   jsr  ldat           ;low order byte to r0, incr rx
;        lda  (r0l,x)        ;high order byte to r0
;        sta  r0h
;        jmp  inr            ;incr rx
;stdat   jsr  stat           ;store indirect low order
;        lda  r0h            ;byte and incr rx. then
;        sta  (r0l,x)        ;store high order byte.
;        jmp  inr            ;incr rx and return
;stpat   jsr  dcr            ;decr rx
;        lda  r0l
;        sta  (r0l,x)        ;store r0 low byte @rx
;        jmp  pop3           ;indicate r0 as last result reg
;dcr     lda  r0l,x
;        bne  dcr2           ;decr rx
;        dec  r0h,x
;dcr2    dec  r0l,x
;        rts
;sub     ldy  $0             ;result to r0
;        cpr  sec            ;note y reg = 13*2 for cpr
;        lda  r0l
;        sbc  r0l,x
;        sta  r0l,y          ;r0-rx to ry
;        lda  r0h
;        sbc  r0h,x
;sub2    sta  r0h,y
;        tya                 ;last result reg*2
;        adc  $0             ;carry to lsb
;        sta  r14h
;        rts
;add     lda  r0l
;        adc  r0l,x
;        sta  r0l            ;r0+rx to r0
;        lda  r0h
;        adc  r0h,x
;        ldy  $0             ;r0 for result
;        beq  sub2           ;finish add
;bs      lda  r15l           ;note x reg is 12*2!
;        jsr  stat2          ;push low pc byte via r12
;        lda  r15h
;        jsr  stat2          ;push high order pc byte
;br      clc
;bnc     bcs  bnc2           ;no carry test
;br1     lda  (r15l),y       ;displacement byte
;        bpl  br2
;        dey
;br2     adc  r15l           ;add to pc
;        sta  r15l
;        tya
;        adc  r15h
;        sta  r15h
;bnc2    rts
;bc      bcs  br
;        rts
;bp      asl                 ;double result-reg index
;        tax                 ;to x reg for indexing
;        lda  r0h,x          ;test for plus
;        bpl  br1            ;branch if so
;        rts
;bm      asl                 ;double result-reg index
;        tax
;        lda  r0h,x          ;test for minus
;        bmi  br1
;        rts
;bz      asl                 ;double result-reg index
;        tax
;        lda  r0l,x          ;test for zero
;        ora  r0h,x          ;(both bytes)
;        beq  br1            ;branch if so
;        rts
;bnz     asl                 ;double result-reg index
;        tax
;        lda  r0l,x          ;test for non-zero
;        ora  r0h,x          ;(both bytes)
;        bne  br1            ;branch if so
;        rts
;bm1     asl                 ;double result-reg index
;        tax
;        lda  r0l,x          ;check both bytes
;        and  r0h,x          ;for $ff (minus 1)
;        eor  $ff
;        beq  br1            ;branch if so
;        rts
;bnm1    asl                 ;double result-reg index
;        tax
;        lda  r0l,x
;        and  r0h,x          ;check both bytes for no $ff
;        eor  $ff
;        bne  br1            ;branch if not minus 1
;nul     rts
;rs      ldx  $18            ;12*2 for r12 as stack pointer
;        jsr  dcr            ;decr stack pointer
;        lda  (r0l,x)        ;pop high return address to pc
;        sta  r15h
;        jsr  dcr            ;same for low order byte
;        lda  (r0l,x)
;        sta  r15l
;        rts
;rtn     jmp  rtnz
;
.popseg
